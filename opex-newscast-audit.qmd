---
title: "Newscast Audit Report"
format: 
  pdf:
    number-sections: false
    suppress-bibliography: true
    keep-tex: false
    include-before-body:
      text: |
        \pagestyle{empty}
    include-in-header:
      text: |
        \usepackage{fancyhdr}
        \pagestyle{empty}
  html:
    page-layout: article
jupyter: python3
execute:
  echo: false
  output: asis
---

```{python}
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter
from IPython.display import Markdown, display
```

```{python}
# Cell 2: load data and standardize column names
# Use a raw path to the workbook
path = r"C:\Users\etalley\OneDrive - TEGNA\WZZM\OpEx\Newscast Audit.xlsx"

df = pd.read_excel(path)

# Standardize column names (explicit mapping for known headers)
column_mapping = {
    'Id': 'id',
    'Start time': 'start_time',
    'Completion time': 'completion_time',
    'Email': 'email',
    'Name': 'name',
    'Date of newscast:': 'newscast_date',
    'Which newscast are you auditing?': 'newscast',
    'Does each story create urgency with time relevance and active writing explaining why stories are being told right now? ': 'urgency_and_why_now',
    'Is a tease to streaming in at least every 30 minutes with specific content push for each show?': 'specific_streaming_tease',
    'Did we use streaming content and/or mobile shorts in this show?': 'streaming_or_mobile_shorts',
    'Are maps, timelines and supporting graphics used within 30 minutes for events and included as useful context in newscasts?': 'maps_graphics',
    'Is there a clearly defined weather story, supported by graphics or video?': 'weather_story_defined',
    'Does each weather hit focus on new/now/next?': 'new_now_next',
    'Does the story address the audience as "you," end with "Here\'s what you can do today"?': 'address_audience_call_to_action',
    'Are anchors shown three times per show on tight shots with name supers?': 'three_tight_anchor_shots_with_supers',
    'Did we specifically reference every piece of file or non-descript video?': 'reference_file_video',
    'Do anchors add local context to two or more stories and include one community-celebration story per hour?': 'local_context',
    'Additional comments below:': 'additional_comments'
}

# Apply exact mapping first (for entries that match)
df = df.rename(columns={k: v for k, v in column_mapping.items() if k in df.columns})

# Some headers use smart quotes or slight variations; find the audience column robustly
for col in df.columns:
    col_lower = str(col).lower()
    if ('what you can do' in col_lower) or ('address the audience' in col_lower) or ("here" in col_lower and "you" in col_lower):
        df = df.rename(columns={col: 'address_audience_call_to_action'})
        break
```

```{python}
# Cell 3: normalize newscast values programmatically
def normalize_newscast(value):
    if pd.isna(value):
        return None
    v = str(value).strip().lower()

    # Specific checks first
    if 'evening+' in v or v.startswith('evening') or 'e+' in v:
        return 'E +'
    if '11' in v and ('pm' in v or 'p.m' in v):
        return '11 pm'
    if '6' in v and ('pm' in v or 'p.m' in v):
        return '6 pm'
    if ('5:30' in v or '5:30pm' in v) and ('pm' in v or 'p.m' in v):
        return '5 pm'
    if ('5' in v) and ('pm' in v):
        return '5 pm'
    if 'noon' in v or '12' in v:
        return 'noon'
    # morning checks
    if ('7' in v) and ('am' in v or 'a-' in v or 'a ' in v):
        return '7 - 9 am'
    if ('5' in v) and ('am' in v or 'a-' in v or 'a ' in v):
        return '5 - 7 am'
    # ranges like '5am to 7am' or '7am to 9am'
    if '5' in v and '7' in v and 'am' in v:
        return '5 - 7 am'
    if '7' in v and '9' in v and 'am' in v:
        return '7 - 9 am'

    # fallback: return original string (trimmed)
    return str(value).strip()

# create column
if 'newscast' in df.columns:
    df['newscast_normalized'] = df['newscast'].apply(normalize_newscast)
else:
    df['newscast_normalized'] = None

```

```{python}
# Cell 4: convert metric columns to numeric by standardized names
# Explicit list of metric column names (only include ones present in the data)
metric_names = [
    'urgency_and_why_now',
    'specific_streaming_tease',
    'streaming_or_mobile_shorts',
    'maps_graphics',
    'weather_story_defined',
    'new_now_next',
    'address_audience_call_to_action',
    'three_tight_anchor_shots_with_supers',
    'reference_file_video',
    'local_context'
]

metric_columns = [c for c in metric_names if c in df.columns]

def convert_to_numeric(v):
    if pd.isna(v):
        return pd.NA
    s = str(v).strip().lower()
    if s in ('yes', 'y', 'true', '1'):
        return 1
    if s in ('no', 'n', 'false', '0'):
        return 0
    if s in ('n/a', 'na', 'none', ''):
        return pd.NA
    # if it's numeric-like, try to coerce
    try:
        num = float(s)
        if num == 1:
            return 1
        if num == 0:
            return 0
    except Exception:
        pass
    return pd.NA

for col in metric_columns:
    df[col] = df[col].apply(convert_to_numeric)
    # convert to nullable integer dtype so 1/0 values remain ints and missing values are <NA>
    try:
        df[col] = df[col].astype('Int64')
    except Exception:
        # if conversion fails, leave as-is
        pass

```

```{python}
# Cell 5: summary by newscast
group_key = 'newscast_normalized' if 'newscast_normalized' in df.columns else 'newscast'
summary = df.groupby(group_key)[metric_columns].mean().round(2)

```

```{python}
# Cell 6: overall summary (not grouped) and recent-week summary


# Overall means (as fraction between 0 and 1)
overall = df[metric_columns].mean(skipna=True)
overall_pct = (overall * 100).round(0).astype(int)

# Transpose to vertical columns: questions as rows, single "Yes %" column
overall_df = overall_pct.rename('Yes %').reset_index().rename(columns={'index': 'Question'})
overall_df['Question'] = overall_df['Question'].str.replace('_', ' ').str.title()
overall_df['Yes %'] = overall_df['Yes %'].astype(str) + '%'
overall_df = overall_df.reset_index(drop=True)
print('## Overall Metrics\n')
print(overall_df.to_markdown(index=False))
print()

# Recent week: use newscast_date if available; otherwise skip
recent_df = None
if 'newscast_date' in df.columns:
    df['newscast_date_parsed'] = pd.to_datetime(df['newscast_date'], errors='coerce')
    if df['newscast_date_parsed'].notna().any():
        max_date = df['newscast_date_parsed'].max()
        # Week starts on Monday; find the most recent Monday
        week_start = max_date - pd.Timedelta(days=max_date.weekday())
        recent = df[df['newscast_date_parsed'] >= week_start]
        if not recent.empty:
            recent_overall = recent[metric_columns].mean(skipna=True)
            recent_df = (recent_overall * 100).round(0).astype(int).rename('Yes %').reset_index().rename(columns={'index':'Question'})
            # Format question labels nicely for display
            recent_df['Question'] = recent_df['Question'].str.replace('_', ' ').str.title()
            recent_df['Yes %'] = recent_df['Yes %'].astype(str) + '%'
            recent_df = recent_df.reset_index(drop=True)
            week_start_str = week_start.strftime('%B %d, %Y')
            print(f'## Current Week Metrics (Starting {week_start_str})\n')
            print(recent_df.to_markdown(index=False))
        else:
            print('\nNo recent-week data found')
    else:
        print('\nNo parsable `newscast_date` values found to compute recent week')
else:
    print('\nNo `newscast_date` column to compute recent week')
```

```{python}
# Cell 7: overall percent vertical bar chart with value labels


# Keep original question order from dataframe
questions = overall_df['Question'].tolist()
values = overall_df['Yes %'].str.rstrip('%').astype(int).tolist()

def cmap_for(v):
    # v is percent 0-100; thresholds: <=40 red, >=80 green, otherwise yellow/gold
    if v <= 40:
        return 'red'
    if v >= 80:
        return 'green'
    return 'gold'

colors = [cmap_for(v) for v in values]

fig, ax = plt.subplots(figsize=(14, max(6, len(questions)*0.4)))
bars = ax.bar(questions, values, color=colors)

# Add value labels on top of each bar
for i, (bar, val) in enumerate(zip(bars, values)):
    ax.text(bar.get_x() + bar.get_width()/2, val + 1, f'{val}%', 
            ha='center', va='bottom', fontsize=9)

ax.set_xlabel('Question')
ax.set_ylabel('Percent Yes')
ax.set_title('Overall Audit Metrics')
ax.yaxis.set_major_formatter(PercentFormatter(xmax=100))
ax.set_ylim(0, 110)
plt.xticks(rotation=45, ha='right')
fig.subplots_adjust(bottom=0.25)
plt.tight_layout()
# save for convenience

plt.show()
```

```{python}
# Cell 8: per-newscast charts (horizontal bar charts only) with value labels
unique_newscasts = df['newscast_normalized'].dropna().unique() if 'newscast_normalized' in df.columns else []
for nc in unique_newscasts:
    sub = df[df['newscast_normalized'] == nc]
    if sub.empty:
        continue
    sub_mean = (sub[metric_columns].mean(skipna=True) * 100).round(0).astype(int)
    # Keep original question order from metric_columns
    questions = [c for c in metric_columns if c in sub_mean.index]
    # Format labels: replace underscore with space and title case
    questions_display = [q.replace('_', ' ').title() for q in questions]
    values = [sub_mean[c] for c in questions]

    # determine colors: <=40 red, >=80 green, otherwise gold
    colors = ['red' if v <= 40 else ('green' if v >= 80 else 'gold') for v in values]

    # horizontal bar chart
    fig, ax = plt.subplots(figsize=(14, max(4, len(questions)*0.35)))
    bars = ax.barh(questions_display, values, color=colors)
    
    # Add value labels on the right side of each bar
    for i, (bar, val) in enumerate(zip(bars, values)):
        ax.text(val + 1, bar.get_y() + bar.get_height()/2, f'{val}%', 
                va='center', fontsize=9)
    
    ax.set_ylabel('Question')
    ax.set_xlabel('Percent Yes')
    ax.set_title(f'{nc} â€” Audit Metrics')
    ax.xaxis.set_major_formatter(PercentFormatter(xmax=100))
    ax.set_xlim(0, 110)
    plt.setp(ax.get_yticklabels(), rotation=0, ha='right', fontsize=9)
    fig.subplots_adjust(left=0.35)
    plt.tight_layout()
    plt.show()


```

```{python}


if 'newscast_date_parsed' in df.columns:
    # Aggregate by week (Monday-based)
    df['week_start'] = df['newscast_date_parsed'] - pd.to_timedelta(df['newscast_date_parsed'].dt.weekday, unit='D')
    weekly_agg = df.groupby('week_start')[metric_columns].mean() * 100
    
    # Create line chart with one line per metric
    fig, ax = plt.subplots(figsize=(14, 6))
    
    # Format labels for legend
    metric_labels = [m.replace('_', ' ').title() for m in metric_columns]
    
    for metric, label in zip(metric_columns, metric_labels):
        ax.plot(weekly_agg.index, weekly_agg[metric], 
                marker='o', label=label, linewidth=2, markersize=6)
    
    ax.set_xlabel('Week Starting (Monday)')
    ax.set_ylabel('Percent (%)')
    ax.set_title('Overall Metrics Over Time (Weekly Aggregation)')
    ax.yaxis.set_major_formatter(PercentFormatter(xmax=100))
    ax.set_ylim(0, 105)
    ax.legend(loc='best', fontsize=9)
    ax.grid(True, alpha=0.3)
    # Set x-axis ticks only at data points
    ax.set_xticks(weekly_agg.index)
    ax.set_xticklabels([d.strftime('%m/%d') for d in weekly_agg.index], rotation=45, ha='right')
    fig.subplots_adjust(bottom=0.15)
    plt.tight_layout()
    plt.show()
else:
    print('\nCannot create timeline chart: newscast_date_parsed not found')
```
